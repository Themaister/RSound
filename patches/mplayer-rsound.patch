diff --git a/Makefile b/Makefile
index b66562b..ecf3c50 100644
--- a/Makefile
+++ b/Makefile
@@ -682,6 +682,8 @@ SRCS_MPLAYER = command.c \
                libao2/ao_mpegpes.c \
                libao2/ao_null.c \
                libao2/ao_pcm.c \
+               libao2/ao_rsound.c \
+               libao2/librsound.c \
                libao2/audio_out.c \
                libvo/aspect.c \
                libvo/geometry.c \
diff --git a/libao2/ao_rsound.c b/libao2/ao_rsound.c
new file mode 100644
index 0000000..d3fc4db
--- /dev/null
+++ b/libao2/ao_rsound.c
@@ -0,0 +1,144 @@
+/*
+ * RSound audio output driver
+ *
+ * This file is part of MPlayer.
+ *
+ * MPlayer is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * MPlayer is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with MPlayer; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "libavutil/common.h"
+#include "mpbswap.h"
+#include "subopt-helper.h"
+#include "libaf/af_format.h"
+#include "libaf/reorder_ch.h"
+#include "audio_out.h"
+#include "audio_out_internal.h"
+#include "mp_msg.h"
+#include "help_mp.h"
+
+#include "rsound.h"
+
+static const ao_info_t info =
+{
+   "RSound output driver",
+   "rsound",
+   "Hans-Kristian Arntzen",
+   ""
+};
+
+LIBAO_EXTERN(rsound)
+
+static char *host = NULL;
+static char *port = NULL;
+static rsound_t* rd = NULL;
+
+static int control(int cmd, void *arg)
+{
+   return -1;
+}
+
+static int init(int rate, int channels, int format, int flags)
+{
+   if ( host )
+      free(host);
+   if ( port )
+      free(port);
+
+   // Parses commandline
+   const opt_t subopts[] = {
+      {"host", OPT_ARG_MSTRZ, &host, NULL},
+      {"port", OPT_ARG_MSTRZ, &port, NULL},
+      {NULL}
+   };
+
+   if (subopt_parse(ao_subdevice, subopts) != 0) {
+      return 0;
+   }
+
+   // Defaults
+   if ( !host )
+      host = strdup("localhost");
+   if ( !port )
+      port = strdup("12345");
+
+   if ( rsd_init(&rd) < 0 )
+      return 0;
+
+   rsd_set_param(rd, RSD_SAMPLERATE, &rate);
+   rsd_set_param(rd, RSD_CHANNELS, &channels);
+   rsd_set_param(rd, RSD_HOST, host);
+   rsd_set_param(rd, RSD_PORT, port);
+   ao_data.channels = channels;
+   ao_data.samplerate = rate;
+   ao_data.format = AF_FORMAT_S16_LE;
+   ao_data.bps = channels*rate*2;
+
+   if ( rsd_start(rd) < 0 )
+      return 0;
+   ao_data.outburst = rd->backend_info.chunk_size;
+   ao_data.buffersize = rd->buffer_size;
+   
+   return 1;
+}
+
+static void uninit(int n)
+{
+   rsd_free(rd);
+}
+
+static void reset(void)
+{
+   rsd_stop(rd);
+   rsd_start(rd);
+}
+
+static void audio_pause(void)
+{
+   rsd_pause(rd, 1);
+}
+
+static void audio_resume(void)
+{
+   rsd_pause(rd, 0);
+}
+
+static int get_space(void)
+{
+   int ptr = rsd_get_avail(rd);
+   return ptr;
+}
+
+static int play(void* data, int len, int flags)
+{
+	(void) flags;
+   int rc = rsd_write(rd, data, len);
+   return rc;
+}
+
+static float get_delay(void)
+{
+   int ptr = rsd_delay(rd);
+   return (float)ptr / (float)ao_data.bps;
+}
+
+
+
+
+
diff --git a/libao2/audio_out.c b/libao2/audio_out.c
index 4ac5489..02d399d 100644
--- a/libao2/audio_out.c
+++ b/libao2/audio_out.c
@@ -53,6 +53,7 @@ extern const ao_functions_t audio_out_dxr2;
 extern const ao_functions_t audio_out_ivtv;
 extern const ao_functions_t audio_out_v4l2;
 extern const ao_functions_t audio_out_mpegpes;
+extern const ao_functions_t audio_out_rsound;
 extern const ao_functions_t audio_out_pcm;
 extern const ao_functions_t audio_out_pss;
 
@@ -122,6 +123,7 @@ const ao_functions_t* const audio_out_drivers[] =
         &audio_out_v4l2,
 #endif
         &audio_out_null,
+        &audio_out_rsound,
 // should not be auto-selected:
         &audio_out_pcm,
         NULL
diff --git a/libao2/librsound.c b/libao2/librsound.c
new file mode 100644
index 0000000..73a52b4
--- /dev/null
+++ b/libao2/librsound.c
@@ -0,0 +1,630 @@
+/*  RSound - A PCM audio client/server
+ *  Copyright (C) 2010 - Hans-Kristian Arntzen
+ * 
+ *  RSound is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RSound is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RSound.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "rsound.h"
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <poll.h>
+#include <errno.h>
+#include <time.h>
+
+static int rsnd_is_little_endian(void);
+static void rsnd_swap_endian_16 ( uint16_t * x );
+static void rsnd_swap_endian_32 ( uint32_t * x );
+static int rsnd_connect_server( rsound_t *rd );
+static int rsnd_send_header_info(rsound_t *rd);
+static int rsnd_get_backend_info ( rsound_t *rd );
+static int rsnd_create_connection(rsound_t *rd);
+static int rsnd_send_chunk(int socket, char* buf, size_t size);
+static int rsnd_start_thread(rsound_t *rd);
+static int rsnd_stop_thread(rsound_t *rd);
+static int rsnd_get_delay(rsound_t *rd);
+static int rsnd_get_ptr(rsound_t *rd);
+static int rsnd_reset(rsound_t *rd);
+static void* rsnd_thread ( void * thread_data );
+
+static int rsnd_is_little_endian(void)
+{
+	uint16_t i = 1;
+	return *((uint8_t*)&i);
+}
+
+static void rsnd_swap_endian_16 ( uint16_t * x )
+{
+	*x = (*x>>8) | (*x<<8);
+}
+
+static void rsnd_swap_endian_32 ( uint32_t * x )
+{
+	*x = 	(*x >> 24 ) |
+			((*x<<8) & 0x00FF0000) |
+			((*x>>8) & 0x0000FF00) |
+			(*x << 24);
+}
+
+static int rsnd_connect_server( rsound_t *rd )
+{
+	struct addrinfo hints, *res;
+	memset(&hints, 0, sizeof( hints ));
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+   
+   getaddrinfo(rd->host, rd->port, &hints, &res);
+
+	rd->conn.socket = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+   rd->conn.ctl_socket = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+
+   if ( connect(rd->conn.socket, res->ai_addr, res->ai_addrlen) < 0)
+      goto error;
+
+	if ( connect(rd->conn.ctl_socket, res->ai_addr, res->ai_addrlen) < 0 )
+      goto error;
+
+   
+   if ( fcntl(rd->conn.socket, F_SETFL, O_NONBLOCK) < 0)
+   {
+      fprintf(stderr, "Couldn't set socket to non-blocking ...\n");
+      goto error;
+   }
+
+	freeaddrinfo(res);
+   return 0;
+error:
+   freeaddrinfo(res);
+	return -1;
+}
+
+static int rsnd_send_header_info(rsound_t *rd)
+{
+#define HEADER_SIZE 44
+	char buffer[HEADER_SIZE] = {0};
+	int rc = 0;
+   struct pollfd fd;
+
+#define RATE 24
+#define CHANNEL 22
+#define FRAMESIZE 34
+
+	uint32_t sample_rate_temp = rd->rate;
+	uint16_t channels_temp = rd->channels;
+	uint16_t framesize_temp = 16;
+
+	if ( !rsnd_is_little_endian() )
+	{
+		rsnd_swap_endian_32(&sample_rate_temp);
+		rsnd_swap_endian_16(&channels_temp);
+		rsnd_swap_endian_16(&framesize_temp);
+	}
+
+	*((uint32_t*)(buffer+RATE)) = sample_rate_temp;
+	*((uint16_t*)(buffer+CHANNEL)) = channels_temp;
+	*((uint16_t*)(buffer+FRAMESIZE)) = framesize_temp;
+
+   fd.fd = rd->conn.socket;
+   fd.events = POLLOUT;
+
+   if ( poll(&fd, 1, 10000) < 0 )
+   {
+		close(rd->conn.socket);
+		close(rd->conn.ctl_socket);
+      return -1;
+   }
+
+   if ( fd.revents & POLLHUP )
+   {
+		close(rd->conn.socket);
+		close(rd->conn.ctl_socket);
+      return -1;
+   }
+
+	rc = send ( rd->conn.socket, buffer, HEADER_SIZE, 0);
+	if ( rc != HEADER_SIZE )
+	{
+		close(rd->conn.socket);
+		close(rd->conn.ctl_socket);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int rsnd_get_backend_info ( rsound_t *rd )
+{
+   #define RSND_HEADER_SIZE 8
+
+   char rsnd_header[RSND_HEADER_SIZE] = {0};
+	int rc;
+
+   struct pollfd fd;
+   fd.fd = rd->conn.socket;
+   fd.events = POLLIN;
+
+   if ( poll(&fd, 1, 10000) < 0 )
+   {
+      close(rd->conn.socket);
+      close(rd->conn.ctl_socket);
+      return -1;
+   }
+
+   if ( fd.revents & POLLHUP )
+   {
+      close(rd->conn.socket);
+      close(rd->conn.ctl_socket);
+      return -1;
+   }
+
+	rc = recv(rd->conn.socket, rsnd_header, RSND_HEADER_SIZE, 0);
+	if ( rc != RSND_HEADER_SIZE)
+	{
+		close(rd->conn.socket);
+      close(rd->conn.ctl_socket);
+		return -1;
+	}
+
+	rd->backend_info.latency = ntohl(*((uint32_t*)(rsnd_header)));
+	rd->backend_info.chunk_size = ntohl(*((uint32_t*)(rsnd_header+4)));
+
+   if ( rd->buffer_size <= 0 || rd->buffer_size < rd->backend_info.chunk_size)
+      rd->buffer_size = rd->backend_info.chunk_size * 32;
+
+	rd->buffer = realloc ( rd->buffer, rd->buffer_size );
+	rd->buffer_pointer = 0;
+
+	return 0;
+}
+
+static int rsnd_create_connection(rsound_t *rd)
+{
+	int rc;
+
+   if ( rd->conn.socket < 0 && rd->conn.ctl_socket < 0 )
+   {
+      rc = rsnd_connect_server(rd);
+      if (rc < 0)
+      {
+         close(rd->conn.socket);
+         close(rd->conn.ctl_socket);
+         rd->conn.socket = -1;
+         rd->conn.ctl_socket = -1;
+         return -1;
+      }
+   }
+   if ( !rd->ready_for_data )
+   {
+      rc = rsnd_send_header_info(rd);
+      if (rc < 0)
+      {
+         rsd_stop(rd);
+         return -1;
+      }
+
+      rc = rsnd_get_backend_info(rd);
+      if (rc < 0)
+      {
+         rsd_stop(rd);
+         return -1;
+      }
+
+      rd->ready_for_data = 1;
+      rc = rsnd_start_thread(rd);
+      if (rc < 0)
+      {
+         rsd_stop(rd);
+         return -1;
+      }
+   }
+	
+   return 0;
+}
+
+static int rsnd_send_chunk(int socket, char* buf, size_t size)
+{
+	int rc = 0;
+   size_t wrote = 0;
+   size_t send_size = 0;
+   struct pollfd fd;
+   fd.fd = socket;
+   fd.events = POLLOUT;
+
+   while ( wrote < size )
+   {
+      if ( poll(&fd, 1, 500) < 0 )
+         return 0;
+
+      if ( fd.revents & POLLHUP )
+         return 0;
+
+      if ( fd.revents & POLLOUT )
+      {
+         send_size = (size - wrote) > 1024 ? 1024 : size - wrote;
+         rc = send(socket, buf + wrote, send_size, 0);
+         if ( rc <= 0 )
+            return 0;
+      }
+      else
+         return 0;
+
+      wrote += rc;
+   }
+	return wrote;
+}
+
+static void rsnd_drain(rsound_t *rd)
+{
+	if ( rd->has_written )
+	{
+		int64_t temp, temp2;
+
+		struct timespec now_tv;
+#ifdef _POSIX_MONOTONIC_CLOCK
+		clock_gettime(CLOCK_MONOTONIC, &now_tv);
+#else
+      clock_gettime(CLOCK_REALTIME, &now_tv);
+#endif
+		
+		temp = (int64_t)now_tv.tv_sec - (int64_t)rd->start_tv.tv_sec;
+		temp *= rd->rate * rd->channels * 2;
+
+		temp2 = (int64_t)now_tv.tv_nsec - (int64_t)rd->start_tv.tv_nsec;
+		temp2 *= rd->rate * rd->channels * 2;
+		temp2 /= 1000000000;
+		temp += temp2;
+
+      rd->bytes_in_buffer = (int)((int64_t)rd->total_written + (int64_t)rd->buffer_pointer - temp);
+   }
+	else
+      rd->bytes_in_buffer = rd->buffer_pointer;
+}
+
+static int rsnd_fill_buffer(rsound_t *rd, const char *buf, size_t size)
+{
+//   struct timespec now;
+//   int nsecs;
+
+   /* Wait until we have a ready buffer */
+   for (;;)
+   {
+      /* Thread has been shut down and, someone still tried to play back. Race conditions? */
+      if ( !rd->thread_active )
+      {
+         return -1;
+      }
+
+      pthread_mutex_lock(&rd->thread.mutex);
+      if (rd->buffer_pointer + (int)size <= (int)rd->buffer_size  )
+      {
+         pthread_mutex_unlock(&rd->thread.mutex);
+         break;
+      }
+      pthread_mutex_unlock(&rd->thread.mutex);
+      
+      /*clock_gettime(CLOCK_REALTIME, &now);
+      nsecs = 50000000;      
+      now.tv_nsec += nsecs;
+      if ( now.tv_nsec >= 1000000000 )
+      {
+         now.tv_sec++;
+         now.tv_nsec -= 1000000000;
+      }*/
+
+      /* get signal from thread to check again */
+      pthread_mutex_lock(&rd->thread.cond_mutex);
+//      pthread_cond_timedwait(&rd->thread.cond, &rd->thread.cond_mutex, &now);
+		pthread_cond_wait(&rd->thread.cond, &rd->thread.cond_mutex);
+      pthread_mutex_unlock(&rd->thread.cond_mutex);
+   }
+
+   pthread_mutex_lock(&rd->thread.mutex);
+   memcpy(rd->buffer + rd->buffer_pointer, buf, size);
+   rd->buffer_pointer += (int)size;
+   pthread_mutex_unlock(&rd->thread.mutex);
+
+   /* send signal to thread that buffer has been updated */
+   pthread_cond_signal(&rd->thread.cond);
+
+   return size;
+}
+
+static int rsnd_start_thread(rsound_t *rd)
+{
+   int rc;
+   if ( !rd->thread_active )
+   {
+      rc = pthread_create(&rd->thread.threadId, NULL, rsnd_thread, rd);
+      if ( rc < 0 )
+      {
+         fprintf(stderr, "Failed to create thread.\n");
+         return -1;
+      }
+      rd->thread_active = 1;
+      return 0;
+   }
+   else
+      return 0;
+}
+
+static int rsnd_stop_thread(rsound_t *rd)
+{
+   if ( rd->thread_active )
+   {
+      if ( pthread_cancel(rd->thread.threadId) < 0 )
+         fprintf(stderr, "Failed to cancel playback thread.\n");
+
+      pthread_join(rd->thread.threadId, NULL);
+      rd->thread_active = 0;
+      pthread_cond_signal(&rd->thread.cond);
+      pthread_mutex_unlock(&rd->thread.mutex);
+      pthread_mutex_unlock(&rd->thread.cond_mutex);
+      return 0;
+   }
+   else
+      return 0;
+}
+
+static int rsnd_get_delay(rsound_t *rd)
+{
+   int ptr;
+   pthread_mutex_lock(&rd->thread.mutex);
+   rsnd_drain(rd);
+   ptr = rd->bytes_in_buffer;
+   pthread_mutex_unlock(&rd->thread.mutex);
+   ptr += (int)rd->backend_info.latency;
+   if ( ptr < 0 )
+      ptr = 0;
+
+// Adds the backend latency
+
+   return ptr;
+}
+
+static int rsnd_get_ptr(rsound_t *rd)
+{
+   int ptr;
+   pthread_mutex_lock(&rd->thread.mutex);
+   ptr = rd->buffer_pointer;
+   pthread_mutex_unlock(&rd->thread.mutex);
+
+   return ptr;
+}
+
+static void* rsnd_thread ( void * thread_data )
+{
+   rsound_t *rd = thread_data;
+   int rc;
+//   struct timespec now;
+//   int nsecs;
+   /* Convert from msecs to bytes */
+   int max_delay = (rd->min_latency * rd->rate * rd->channels * 2) / 1000;
+   if ( max_delay > 0 )
+      max_delay = ((int)rd->buffer_size > max_delay) ? (int)rd->buffer_size : max_delay;
+   else
+      max_delay = 0;
+
+   /* Plays back data as long as there is data in the buffer */
+   for (;;)
+   {
+      /* Trying to compensate for latency. Makes sure that the delay never goes over a certain amount */
+      while ( (rd->buffer_pointer >= (int)rd->backend_info.chunk_size) && ( !max_delay || (rsd_delay(rd) <= max_delay) ) )
+      {
+         rc = rsnd_send_chunk(rd->conn.socket, rd->buffer, rd->backend_info.chunk_size);
+         if ( rc <= 0 )
+         {
+            rsnd_reset(rd);
+            pthread_cond_signal(&rd->thread.cond);
+            pthread_exit(NULL);
+         }
+         
+         if ( !rd->has_written )
+         {
+            pthread_mutex_lock(&rd->thread.mutex);
+#ifdef _POSIX_MONOTONIC_CLOCK
+            clock_gettime(CLOCK_MONOTONIC, &rd->start_tv);
+#else
+            clock_gettime(CLOCK_REALTIME, &rd->start_tv);
+#endif
+            rd->has_written = 1;
+            pthread_mutex_unlock(&rd->thread.mutex);
+         }
+
+         pthread_mutex_lock(&rd->thread.mutex);
+         rd->total_written += rc;
+         pthread_mutex_unlock(&rd->thread.mutex);
+
+         pthread_mutex_lock(&rd->thread.mutex);
+         memmove(rd->buffer, rd->buffer + rd->backend_info.chunk_size, rd->buffer_size - rd->backend_info.chunk_size);
+         rd->buffer_pointer -= (int)rd->backend_info.chunk_size;
+         pthread_mutex_unlock(&rd->thread.mutex);
+
+         /* Buffer has decreased, signal fill_buffer */
+         pthread_cond_signal(&rd->thread.cond);
+
+                          
+      }
+      /* Wait for the buffer to be filled. Wakeup at least every 5ms. */
+      /*clock_gettime(CLOCK_REALTIME, &now);
+      nsecs = 5000000;      
+      now.tv_nsec += nsecs;
+      if ( now.tv_nsec >= 1000000000 )
+      {
+         now.tv_sec++;
+         now.tv_nsec -= 1000000000;
+      }*/
+
+      pthread_mutex_lock(&rd->thread.cond_mutex);
+//      pthread_cond_timedwait(&rd->thread.cond, &rd->thread.cond_mutex, &now);
+		pthread_cond_wait(&rd->thread.cond, &rd->thread.cond_mutex);
+      pthread_mutex_unlock(&rd->thread.cond_mutex);
+   }
+}
+
+static int rsnd_reset(rsound_t *rd)
+{
+   rd->conn.socket = -1;
+   rd->conn.ctl_socket = -1;
+   rd->total_written = 0;
+   rd->ready_for_data = 0;
+   rd->has_written = 0;
+   rd->bytes_in_buffer = 0;
+   rd->thread_active = 0;
+   pthread_mutex_unlock(&rd->thread.mutex);
+   pthread_mutex_unlock(&rd->thread.cond_mutex);
+   return 0;
+}
+
+
+int rsd_stop(rsound_t *rd)
+{
+   const char buf[] = "CLOSE";
+   rsnd_stop_thread(rd);
+   
+   send(rd->conn.ctl_socket, buf, strlen(buf) + 1, 0);
+   close(rd->conn.ctl_socket);
+   close(rd->conn.socket);
+   
+   rsnd_reset(rd);
+   return 0;
+}
+
+int rsd_write( rsound_t *rsound, const char* buf, size_t size)
+{
+   int result;
+   
+   result = rsnd_fill_buffer(rsound, buf, size);
+
+   if ( result <= 0 )
+   {
+      rsd_stop(rsound);
+      return -1;
+   }
+   return result;
+}
+
+int rsd_start(rsound_t *rsound)
+{
+   if ( rsound->rate == 0 || rsound->channels == 0 || rsound->host == NULL || rsound->port == NULL )
+      return -1;
+   return ( rsnd_create_connection(rsound) );
+}
+
+int rsd_set_param(rsound_t *rd, int option, void* param)
+{
+   switch(option)
+   {
+      case RSD_SAMPLERATE:
+         rd->rate = *((int*)param);
+         break;
+      case RSD_CHANNELS:
+         rd->channels = *((int*)param);
+         break;
+      case RSD_HOST:
+         if ( rd->host != NULL )
+            free(rd->host);
+         rd->host = strdup((char*)param);
+         break;
+      case RSD_PORT:
+         if ( rd->port != NULL )
+            free(rd->port);
+         rd->port = strdup((char*)param);
+         break;
+      case RSD_BUFSIZE:
+         rd->buffer_size = *((int*)param);
+         break;
+      case RSD_LATENCY:
+         rd->min_latency = *((int*)param);
+         break;
+      default:
+         return -1;
+   }
+   return 0;
+         
+}
+
+int rsd_pointer(rsound_t *rsound)
+{
+   int ptr;
+
+   ptr = rsnd_get_ptr(rsound);	
+
+   return ptr;
+}
+
+int rsd_get_avail(rsound_t *rd)
+{
+   int ptr;
+   ptr = rsnd_get_ptr(rd);
+   return rd->buffer_size - ptr;
+}
+
+int rsd_delay(rsound_t *rd)
+{
+   int ptr = rsnd_get_delay(rd);
+   if ( ptr < 0 )
+      ptr = 0;
+   
+   return ptr;
+}
+
+int rsd_pause(rsound_t* rsound, int enable)
+{
+   if ( enable )
+      rsd_stop(rsound);
+   else
+      rsd_start(rsound);
+   return 0;
+}
+
+int rsd_init(rsound_t** rsound)
+{
+	*rsound = calloc(1, sizeof(rsound_t));
+	if ( *rsound == NULL )
+	{
+		return -1;
+	}
+   
+   (*rsound)->conn.socket = -1;
+   (*rsound)->conn.ctl_socket = -1;
+
+   pthread_mutex_init(&(*rsound)->thread.mutex, NULL);
+   pthread_mutex_init(&(*rsound)->thread.cond_mutex, NULL);
+   pthread_cond_init(&(*rsound)->thread.cond, NULL);
+
+   return 0;
+}
+
+int rsd_free(rsound_t *rsound)
+{
+   if (rsound)
+   {
+      if (rsound->buffer)
+         free(rsound->buffer);
+      if (rsound->host)
+         free(rsound->host);
+      if (rsound->port)
+         free(rsound->port);
+      free(rsound);
+      return 0;
+   }
+   else
+      return -1;
+}
+
diff --git a/libao2/rsound.h b/libao2/rsound.h
new file mode 100644
index 0000000..05da4df
--- /dev/null
+++ b/libao2/rsound.h
@@ -0,0 +1,81 @@
+#ifndef __RSOUND_H
+#define __RSOUND_H
+
+#define _POSIX_SOURCE
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <time.h>
+#include <stdint.h>
+
+enum {
+   RSD_SAMPLERATE = 0,
+   RSD_CHANNELS,
+   RSD_HOST,
+   RSD_PORT,
+   RSD_BUFSIZE,
+   RSD_LATENCY
+};
+
+typedef struct connection
+{
+   int socket;
+   int ctl_socket;
+} connection_t;
+
+typedef struct rsound_thread
+{
+   pthread_t threadId;
+   pthread_mutex_t mutex;
+   pthread_mutex_t cond_mutex;
+   pthread_cond_t cond;
+} rsound_thread_t;
+
+typedef struct backend_info
+{
+   // Inherit latency from backend that must be added to the calculated latency . 
+   uint32_t latency;
+   uint32_t chunk_size;
+} backend_info_t;
+
+typedef struct rsound
+{
+   connection_t conn;
+   char *host;
+   char *port;
+   char *buffer;
+
+   int buffer_pointer;
+   size_t buffer_size;
+   int thread_active;
+
+   int64_t total_written;
+   struct timespec start_tv;
+   int has_written;
+   int bytes_in_buffer;
+   int min_latency;
+   backend_info_t backend_info;
+
+   int ready_for_data;
+
+   uint32_t rate;
+   uint32_t channels;
+
+   rsound_thread_t thread;
+} rsound_t;
+
+int rsd_init (rsound_t **rd);
+int rsd_free (rsound_t *rd);
+int rsd_start (rsound_t *rd);
+int rsd_set_param (rsound_t *rd, int option, void* param);
+int rsd_stop (rsound_t *rd);
+int rsd_write (rsound_t *rd, const char* buf, size_t size);
+int rsd_pointer (rsound_t *rd);
+int rsd_get_avail (rsound_t *rd);
+int rsd_delay (rsound_t *rd);
+int rsd_pause (rsound_t *rd, int enable);
+
+#endif
+
+
+
